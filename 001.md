## 一、总体目标（你要做什么）
- 接收无人机的实时状态（HTTP，JSON）。
- 实时把状态推送给前端（WebSocket）。
- 把时序数据存储到时序数据库（InfluxDB），用于统计与查询。
- 将业务数据持久化到关系型数据库（MySQL）。
- 提供历史数据查询与导出（CSV 或通过 MySQL 记录任务状态）。
- 提供在线数量统计、健康检查等辅助接口。
- 提供一个模拟客户端用于测试（drone-client）。

## 二、项目组件与职责（先认识每个服务）
- `drone-api`：负责接收无人机上报，校验数据，写入 InfluxDB，广播给 WebSocket 客户端，并返回请求状态（主要实现实时接入）。
- `drone-stats-service`：负责把业务数据写入 MySQL、提供聚合查询、处理导出任务（主要实现统计与历史查询）。
- `influxDB`：时序数据库，存储无人机在时间轴上的数据点。
- `drone-client`：模拟无人机上报，便于调试系统。
- `ui`：前端页面，用来显示实时位置、列表和导出入口。

下面逐项说明需要实现的功能点，以及每个服务里是如何实现它们的。

## 三、功能点 1：接收无人机实时状态（HTTP 接口）

**目的**：实现一个 HTTP 接口，让无人机或模拟器能把最新位置、速度、高度、电量等信息发送到后端。

**在哪实现**：`drone-api` 服务中（文件 `drone-api/internal/handler/handledronestatushandler.go`）。

**要实现的细节**：
1. **接口地址**：`POST /api/drone/status`
2. **请求格式**（JSON）：
   ```json
   {
     "id": "uas-001",
     "latitude": 22.800721,
     "longitude": 113.953099,
     "altitude": 15.0,
     "speed": 3.5,
     "battery": 90,
     "timestamp": 1670000000
   }
   ```
3. **成功返回**（HTTP 200）：
   ```json
   {
     "code": 0,
     "message": "ok"
   }
   ```
4. **错误返回**（HTTP 400）：
   ```json
   {
     "code": 4001,
     "message": "missing field: id"
   }
   ```

**handler 流程步骤**：
**handler 流程步骤**：
1. 解析请求体 JSON。
2. 校验必填字段（`id`、`latitude`、`longitude`、`timestamp`）。
3. 转换单位或格式（可选）。
4. 将数据广播给 WebSocket Hub（用于实时展示）。
5. 通过内部接口把数据发给 `drone-stats-service` 或直接写入 InfluxDB。
6. 返回成功响应。

**伪代码示例**：
```go
func HandleDroneStatus(w http.ResponseWriter, r *http.Request) {
  var req DroneStatusReq
  if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
    writeJSON(w, 400, ErrInvalidJSON)
    return
  }
  if req.ID == "" {
    writeJSON(w, 400, ErrMissingID)
    return
  }
  // 校验并标准化字段...
  hub.Broadcast(NewWSMessage("drone_status", req))
  go sendToStatsService(req)
  writeJSON(w, 200, OKResponse)
}
```

**注意点**：
- 记录关键日志（接收到的 `id`、`timestamp` 等）。
- 返回清晰的错误码与说明，便于调试。

## 四、功能点 2：实时推送（WebSocket）

**目的**：前端通过 WebSocket 连接，能实时收到 `drone-api` 收到的每条状态。

**在哪实现**：`drone-api` 内（文件 `internal/websocket/hub.go` 与 `internal/handler/handlewebsockethandler.go`）。

**实现步骤**：
1. 建立一个 Hub（管理连接的结构体），保存所有连接与发送队列。
2. WebSocket handler 接收到升级请求后，把连接注册到 Hub。
3. 当 `HandleDroneStatus` 收到数据时，调用 `hub.Broadcast(msg)` 把消息发送给所有连接。
4. 客户端收到消息后解析 JSON 并更新地图或列表。

**消息格式建议**：
```json
{
  "type": "drone_status",
  "payload": { ... }
}
```

**实现要点**：
- 并发安全：使用 channel 或互斥锁保护连接集合。
- 避免阻塞：异步发送消息。
- 心跳机制：定期发送 ping，清理失联连接。

## 五、功能点 3：时序写入与查询（drone-stats-service + InfluxDB）

**目的**：把无人机按时间序列的数据保存下来，方便做统计、历史轨迹查询和导出。

**在哪实现**：`drone-stats-service` 负责和 InfluxDB 交互，`influxDB` 提供存储。

**写入步骤**：
1. 定义 measurement 名称（如 `drone_status`），并把 `drone_id` 作为 tag。
2. 字段包括：lat、lon、altitude、speed、battery 等。
3. 在 `drone-stats-service/internal/dao/influx.go` 实现 `WritePoint(measurement, tags, fields, timestamp)`。
4. `drone-api` 将状态推送给 `drone-stats-service`，后者在收到后写入 InfluxDB。

**查询步骤**：
1. 在 `drone-stats-service/internal/handler/` 中实现查询接口，例如 `GET /api/stats/trajectory?drone_id=xxx&start=...&end=...`。
2. 根据参数构造 InfluxDB 查询，返回时间序列点或聚合结果。

**注意点**：
- 查询时要注意时间范围、分页和返回的数据量。
- 避免一次性返回过多数据导致前端卡顿。

## 五点五：MySQL 持久化说明

**为什么要写到 MySQL？**
- InfluxDB 适合做时序查询、聚合与快速检索，但业务级记录（如一趟飞行的元数据、导出任务状态、统计汇总）更适合关系型数据库保存，便于导出、报表和事务保证。

**要存哪些数据（常见表）**：
- `flight_records`：飞行架次主记录（OrderID、uasID、起止时间、起止经纬度、总距离、耗电量、载荷等）。
- `flight_track_points`：架次轨迹点（时间、经纬度、高度、速度、航向、电量等）。
- `flight_sorties`：在线/状态统计表（快速统计在线数）。
- `export_tasks`：导出任务表（参数、状态、文件路径等）。

**在代码里怎么做（高层流程）**：
- 采集原始点后，通过逻辑层识别完整飞行（从 TakeOff 到 Land）。
- 计算总距离、耗电等统计数据。
- 调用 MySQL DAO（`SaveFlightRecordAndGetOrderID`、`SaveTrackPoints`）写入 MySQL。
- 写入前调用 `FlightRecordExists` 检查重复。

**容错与重试策略**：
- 同步写入失败时，会进行有限次数重试（指数退避）。
- 若仍失败，本次批次入本地持久化队列。
- `startReplayer` 后台协程定期重放，保证数据最终一致性。

**导出与回填**：
- 通过 `GetFlightRecordsLogic` 判断有效架次。
- 若不存在则插入主表返回 `orderID`，随后批量插入轨迹点。
- 主表存在但轨迹点缺失时，尝试回填轨迹点。

**测试与验证**：
- 运行 `drone-stats-service` 后，通过查询接口生成飞行记录。
- 使用数据库客户端查询 `flight_records` 表，确认有新记录。
- 查看 `drone-stats-service/log/` 日志，确认重试/入队信息。

## 六、功能点 4：导出历史记录（异步任务）

**目的**：用户在前端请求导出历史飞行记录（例如某架无人机一个月的数据），后台生成 CSV 并提供下载。

**在哪实现**：`drone-stats-service/internal/export/`

**实现思路**：
1. 前端发起导出请求 -> `drone-stats-service` 创建导出任务记录（MySQL `export_tasks` 表，状态：pending）。
2. 后台 worker 从任务表中取出 pending 任务，执行查询并把数据写成 CSV。
3. 保存到文件系统或对象存储。
4. 更新任务状态为 completed，把下载地址写回任务记录。
5. 前端轮询任务状态或使用 WebSocket 推送完成通知，用户点击下载。

**实现要点**：
- 长时间任务不要阻塞 HTTP 请求。
- 使用数据库记录任务。
- 由独立进程处理。

## 七、功能点 5：在线数量统计与健康检查

**目的**：让平台能告诉用户当前在线的无人机数量或服务是否健康。

**在哪实现**：`drone-api` 提供在线统计接口，`drone-stats-service` 可提供更复杂的统计。

**实现方式（简单版）**：
1. 在 `drone-api` 的 Hub 中维护一个 map（drone_id -> last_seen_timestamp）。
2. 每次收到该 id 的上报，更新 `last_seen`。
3. 提供接口 `GET /api/online/count`，遍历 map，统计在最近 N 秒内有上报的 id 数量。

**注意点**：
- 如果无人机通过不同连接上报（例如 TCP/UDP），需要统一 id 的来源并去重。

## 八、模拟客户端（drone-client）

**目的**：模拟多架飞机周期性上报，用来测试实时链路、统计写入和导出流程。

**实现要点**：
1. `client.go` 中实现主循环：每隔 N 秒计算新位置（使用 `flight/flight.go` 的地理计算）。
2. 向 `POST /api/drone/status` 发送 JSON。
3. 支持命令行参数：`-id`、`-lat`、`-lon`、`-bearing`、`-interval`，便于并行模拟多台无人机。

**用途**：检验 `drone-api` 接收、WebSocket 推送和 `drone-stats-service` 写入的整体工作流程。

## 九、代码结构映射与实践建议

**目录与职责分工**：
- **Handler**（HTTP 路由）：放 `internal/handler/`，负责解析请求、返回结果与简单校验。
- **业务逻辑**：放 `internal/logic/`，复杂处理、调用 DAO 或外部服务。
- **数据访问**：放 `internal/dao/`，InfluxDB、MySQL 等具体读写封装。
- **WebSocket 管理**：放 `internal/websocket/`。

**接收请求到广播的调用链示例**：
1. `routes.go` 注册 `POST /api/drone/status` -> `handledronestatushandler.go`。
2. `handledronestatushandler.go` 解析并校验请求，调用 `logic.ProcessDroneStatus(ctx, req)`。
3. `logic.ProcessDroneStatus` 会：
   - 转换并校验数据。
   - 调用 DAO 写入 Influx（或发送到 `drone-stats-service`）。
   - 调用 `websocket.Hub.Broadcast` 把消息推送给所有前端连接。
   - 返回结果。

## 十、开发与调试小技巧

- 每实现一个接口就写一个简单的 curl 测试，确认输入输出。
- 先实现最简单的同步写入（直接在 `drone-api` 触发写入），等跑通再迁移到 `drone-stats-service`。
- 用日志输出关键步骤（收到请求、校验失败、写入成功、广播成功）。
- 写清楚接口文档（字段、单位、示例），便于前端与模拟器配合。

## 十一、示例接口规范

**`POST /api/drone/status` 接口**：
- 请求 JSON 字段：`id`(string)、`latitude`(float)、`longitude`(float)、`altitude`(float)、`speed`(float)、`battery`(int)、`timestamp`(int)
- 成功返回：`HTTP 200` 
  ```json
  { "code": 0, "message": "ok" }
  ```
- 错误返回：`HTTP 400`
  ```json
  { "code": 4001, "message": "missing id" }
  ```

## 十二、小结与下一步建议

**你现在已经知道**：
- 每个服务要实现哪些功能。
- 这些功能应该放到哪些文件夹或模块。
- 实现时的注意点。

**下一步建议**：
1. 在本地实现并测试 `POST /api/drone/status` 的 handler。
2. 实现一个最简单的 Hub（只做广播，不做复杂连接管理），并让 handler 广播收到的消息。
3. 使用 `drone-client` 模拟一台无人机，观察日志与前端是否有数据。

---

## 前端实现与设计说明

下面补充前端（`ui/` 目录）搭建与实现的流程、关键点与建议，便于前后端联调与后续迭代。

### 前端总体架构

- **技术栈**：静态页面 + 原生 JavaScript / 小量第三方库（echarts、three.js、swiper 等）。
- **目录说明**：
  - `ui/index.html`：主入口。
  - `ui/js/`：交互逻辑（droneMap.js 负责地图显示与实时点位）。
  - `ui/css/`：样式。
  - `ui/export.html`、`ui/uploadPayload.html`：功能页。
- **部署方式**：静态服务器（nginx、Python HTTP Server）或 CDN。前端只需访问 `drone-api` 的 HTTP 与 WebSocket。

### 关键实现点（实时数据）

**WebSocket 连接**：
- **连接建立**：open 后发送订阅或身份（可选），并设置 ping 定时器保活。
- **重连策略**：断开后按指数退避重连（避免短时间内大量重连）。
- **消息处理**：统一按 `type` 字段分发（例如 `drone_status`、`export_status`、`health`）。

**展示更新**：
- 更新内存数据结构。
- 刷新地图标记（或更新折线）。
- 更新侧边列表与状态栏。
- 地图渲染尽量做最小化更新以保证性能。

### 页面与组件（建议划分）

- **地图视图（MapView）**：展示所有无人机当前位置与轨迹。复用 `droneMap.js` 并把渲染和数据处理解耦。
- **列表视图（ListView）**：展示在线列表、最后上报时间、电量等，支持搜索与筛选。
- **详情面板（DetailPanel）**：点击列表或地图点弹出，显示详细信息与历史轨迹入口、导出入口。
- **导出任务页（export.html）**：提供导出参数（时间段、drone_id），展示导出任务状态。
- **设置/运维（可选）**：WebSocket 地址、刷新间隔、聚合阈值等配置项。

### 前后端交互细节

- **实时上报显示**：后端推送的 `drone_status` 包含：`id, latitude, longitude, altitude, speed, battery, timestamp`。前端根据 `timestamp` 判断是否丢帧或乱序。
- **历史轨迹查询**：前端通过 `GET /api/stats/trajectory?drone_id=xxx&start=...&end=...` 拉取点序列。后端支持分页或降采样参数（例如 `max_points`）。
- **导出任务交互**：前端 POST 导出请求到 `drone-stats-service`，轮询 `GET /api/export/tasks/:id` 或监听 WebSocket 的 `export_status` 消息。

### 运行、调试与本地托管

**快速本地查看**：
```bash
cd ui
python3 -m http.server 8080
# 访问 http://localhost:8080
```

**使用 nginx 提供静态文件**：
- 把 `ui/` 目录指向 nginx 的 `root`。
- 在 `nginx_drone.conf` 中配置反向代理 `/api/` 到后端服务。
- 配置 `/ws` 的 `proxy_pass`（注意 `upgrade` 与 `proxy_set_header`）。

**跨域（CORS）**：
- 若前端与后端不在同域，后端需要允许 `Origin`。
- 设置 `Access-Control-Allow-Credentials`。
- WebSocket 的跨域策略也需配置。

### Nginx 反向代理与示例（关联实际接口）

项目根目录包含 `nginx_drone.conf`，把静态文件、HTTP API 与 WebSocket 通过同一 Nginx 暴露出去。

**后端服务映射**：
- `drone-api`（内部端口 19999）在 `drone-api/internal/handler/routes.go` 注册：
  - `POST /api/drone/status` —— 接收无人机状态上报。
  - `GET  /api/drone/online_count` —— 在线数量查询。
  - `GET  /api/ws` —— WebSocket 升级端点。
- `drone-stats-service` 及其他服务分别运行在各自端口。

**nginx_drone.conf 关键映射**：
- `location /api/ws` -> `proxy_pass http://localhost:19999;`（WebSocket）
- `location /api/` -> `proxy_pass http://localhost:19999;`（HTTP API）
- `location /record` -> `proxy_pass http://localhost:8088;`
- `location /vehicle/ws` 与 `location /vehicle/` -> `proxy_pass http://localhost:8060;`

**WebSocket 必备配置**：
```
proxy_http_version 1.1;
proxy_set_header Upgrade $http_upgrade;
proxy_set_header Connection 'upgrade';
proxy_set_header Host $host;
proxy_set_header X-Real-IP $remote_addr;
proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
proxy_set_header X-Forwarded-Proto $scheme;
```

**联调示例**：
- 通过 Nginx 提交无人机状态：
  ```bash
  curl -X POST http://<nginx-host>:8080/api/drone/status \
    -H "Content-Type: application/json" \
    -d '{"id":"uas-001","latitude":22.8,"longitude":113.95,"altitude":15.0,"speed":3.5,"battery":90,"timestamp":1670000000}'
  ```
- 在浏览器中建立 WebSocket：
  ```js
  const ws = new WebSocket('ws://<nginx-host>:8080/api/ws');
  ws.onopen = () => console.log('ws open');
  ws.onmessage = e => console.log('msg', JSON.parse(e.data));
  ```
- 查询在线数量：
  ```bash
  curl -X GET http://<nginx-host>:8080/api/drone/online_count
  ```

**调试与注意事项**：
- 确认 `drone-api` 实际监听端口与 `proxy_pass` 保持一致。
- 若使用 TLS（https/wss），在 Nginx 配置证书并将外部 TLS 终止。
- 多服务共享 Nginx 时，小心 `location` 匹配顺序与前缀覆盖问题。

通过这些映射，前端只连接 Nginx（如 `http://nginx-host:8080`），方便前端部署、跨域配置和统一访问入口。
